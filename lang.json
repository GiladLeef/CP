{
  "tokens": [
    { "type": "COMMENT", "regex": "//[^\\n]*" },
    { "type": "CLASS", "regex": "class" },
    { "type": "SELF", "regex": "self" },
    { "type": "NEW", "regex": "new" },
    { "type": "IF", "regex": "if" },
    { "type": "ELSE", "regex": "else" },
    { "type": "WHILE", "regex": "while" },
    { "type": "FOR", "regex": "for" },
    { "type": "DO", "regex": "do" },
    { "type": "INT", "regex": "int" },
    { "type": "FLOAT", "regex": "float" },
    { "type": "CHAR", "regex": "char" },
    { "type": "RETURN", "regex": "return" },
    { "type": "FLOAT_NUMBER", "regex": "\\d+\\.\\d+" },
    { "type": "NUMBER", "regex": "\\d+" },
    { "type": "CHAR_LITERAL", "regex": "'[^']'" },
    { "type": "ID", "regex": "[a-zA-Z_][a-zA-Z0-9_]*" },
    { "type": "LPAREN", "regex": "\\(" },
    { "type": "RPAREN", "regex": "\\)" },
    { "type": "LBRACE", "regex": "\\{" },
    { "type": "RBRACE", "regex": "\\}" },
    { "type": "SEMICOLON", "regex": ";" },
    { "type": "COMMA", "regex": "," },
    { "type": "PLUS", "regex": "\\+" },
    { "type": "MINUS", "regex": "-" },
    { "type": "MULT", "regex": "\\*" },
    { "type": "DIV", "regex": "/" },
    { "type": "MOD", "regex": "%" },
    { "type": "BITAND", "regex": "&" },
    { "type": "BITXOR", "regex": "\\^" },
    { "type": "BITOR", "regex": "\\|" },
    { "type": "LSHIFT", "regex": "<<" },
    { "type": "RSHIFT", "regex": ">>" },
    { "type": "EQEQ", "regex": "==" },
    { "type": "NEQ", "regex": "!=" },
    { "type": "LTE", "regex": "<=" },
    { "type": "GTE", "regex": ">=" },
    { "type": "EQ", "regex": "=" },
    { "type": "LT", "regex": "<" },
    { "type": "GT", "regex": ">" },
    { "type": "STRING", "regex": "\"[^\"]*\"" },
    { "type": "DOT", "regex": "\\." },
    { "type": "WS", "regex": "\\s+" }
  ],
  "operators": {
    "binOpMap": {
      "+": ["add", "fadd", "addtmp"],
      "-": ["sub", "fsub", "subtmp"],
      "*": ["mul", "fmul", "multmp"],
      "/": ["sdiv", "fdiv", "divtmp"],
      "%": ["srem", "srem", "remtmp"],
      "&": ["and_", "and_", "andtmp"],
      "^": ["xor", "xor", "xortmp"],
      "|": ["or_", "or_", "ortmp"],
      "<<": ["shl", "shl", "shltmp"],
      ">>": ["lshr", "lshr", "lshrtmp"]
    },
    "compMap": {
      "EQEQ": ["==", "==", "eqtmp"],
      "NEQ": ["!=", "!=", "neqtmp"],
      "LT": ["<", "<", "lttmp"],
      "GT": [">", ">", "gttmp"],
      "LTE": ["<=", "<=", "letmp"],
      "GTE": [">=", ">=", "getmp"]
    },
    "precedences": {
      "MULT": 4,
      "DIV": 4,
      "MOD": 4,
      "PLUS": 3,
      "MINUS": 3,
      "LSHIFT": 2,
      "RSHIFT": 2,
      "EQEQ": 2,
      "NEQ": 2,
      "LT": 2,
      "GT": 2,
      "LTE": 2,
      "GTE": 2,
      "BITAND": 1,
      "BITXOR": 1,
      "BITOR": 1
    }
  },
  "datatypes": {
    "int": "IntType(32)",
    "float": "FloatType()",
    "char": "IntType(8)",
    "string": "PointerType(IntType(8))"
  },
  "astNodes": [
    { "name": "Program", "fields": ["functions", "classes"] },
    { "name": "Function", "fields": ["name", "body"] },
    { "name": "MethodDecl", "fields": ["name", "parameters", "body", "className", "returnType"] },
    { "name": "Return", "fields": ["expr"] },
    { "name": "ExpressionStatement", "fields": ["expr"] },
    { "name": "VarDecl", "fields": ["name", "init", "datatypeName"] },
    { "name": "BinOp", "fields": ["op", "left", "right"] },
    { "name": "Num", "fields": ["value"] },
    { "name": "FloatNum", "fields": ["value"] },
    { "name": "Var", "fields": ["name"] },
    { "name": "String", "fields": ["value"] },
    { "name": "Char", "fields": ["value"] },
    { "name": "FunctionCall", "fields": ["callee", "args"] },
    { "name": "ClassDecl", "fields": ["name", "fields", "methods"] },
    { "name": "MemberAccess", "fields": ["objectExpr", "memberName"] },
    { "name": "Assign", "fields": ["left", "right"] },
    { "name": "If", "fields": ["condition", "thenBranch", "elseBranch"] },
    { "name": "While", "fields": ["condition", "body"] },
    { "name": "For", "fields": ["init", "condition", "increment", "body"] },
    { "name": "DoWhile", "fields": ["body", "condition"] },
    { "name": "NewExpr", "fields": ["className"] }
  ],
  "statementParseMap": {
    "RETURN": "parseReturn",
    "IF": "parseIf",
    "WHILE": "parseWhile",
    "FOR": "parseFor",
    "DO": "parseDoWhile",
    "SELF": "parseIdentifier"
  },
  "factorParseMap": {
    "NUMBER": { "method": "parseLiteral", "args": ["NUMBER", "Num"] },
    "FLOAT_NUMBER": { "method": "parseLiteral", "args": ["FLOAT_NUMBER", "FloatNum"] },
    "STRING": { "method": "parseLiteral", "args": ["STRING", "String"] },
    "CHAR_LITERAL": { "method": "parseLiteral", "args": ["CHAR_LITERAL", "Char"] },
    "ID": "parseIdentifier",
    "SELF": "parseIdentifier",
    "LPAREN": "parseParenthesizedExpression"
  }
}
